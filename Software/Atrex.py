from PyQt4 import QtCore, QtGui, uic
from myImage import *
from tifffile import *
from myImDisplay import *
from atrex_utils import *
from myMask import *
from myPeaks import *
from MyOverlayDlg import *
from JCPDS import *
from scipy import ndimage
import sys
import os.path
import time
import myPeakTable
import myDetector
from peakFit import *
from myPredict import *
from myPeakAdjustDlg import *
from Project import *
from locmax import *
import simulateDlg

##
# Atrex
# Top level class of the Atrex software package.
# Loads uiMainWin.ui and handles all events generated by the ui. This is the main control class of the Atrex package.
class Atrex(QtGui.QMainWindow):
    displayedImage = False
    minRange = 1
    maxRange = 99
    mergeSumMode = True
    mymask = myMask()
    mypred = myPredict ()
    olayFile =""
    olaySecFlag = False
    firstDisplay = True
    imtypeFlag = 0
    selectPeakXY =[0.,0.]
    imsize = (0,0)
    peakBoxSize = 33
    oldSelected = -1
    vertProfFlag = True
    peakStartx = 0
    peakStarty = 0
    mergeArr = None
    mergeFileName = None
    mergeDisplayFlag = False
    imageFilePref = None
    myproj = Project()


    def __init__(self):
        ##
        # init - Constructor for the atrex class.
        # Initialize the gui controls, hook signals to slots.
        # Initialize class attributes. <br>
        # Called on class instantiation

        QtGui.QMainWindow.__init__(self)
        self.ui = uic.loadUi("uiMainWin.ui", self)
        self.myLogWidget = self.ui.sessionLogWidget
        self.ui.refSampleTabWidget.setColumnWidth (1, 250)
        self.ui.refSampleTabWidget.setHorizontalHeaderLabels (QtCore.QStringList()<< "Name" << "Value")
        self.ui.sampleReflectTabWidget.setHorizontalHeaderLabels \
            (QtCore.QStringList()<< "D-Spacing" << "Intensity" << "H"<<"K"<<"L")
        #self.ui.refSampleTabWidget.verticalHeader().setRowHeight (8)
        self.ui.openImageButton.clicked.connect(self.openImage)
        self.ui.browseImageDirButton.clicked.connect(self.defImageDir)
        self.ui.browseWorkDirButton.clicked.connect(self.defWorkDir)
        self.ui.rangeSlider.valueChanged.connect(self.newSliderValue)
        self.ui.rangeSlider.sliderReleased.connect(self.newImageValue)
        self.ui.incrementImageButton.clicked.connect(self.incrementImageValue)
        self.ui.decrementImageButton.clicked.connect(self.decrementImageValue)
        self.ui.mergeButton.clicked.connect(self.mergeImageRange)
        self.ui.mergeCancelButton.clicked.connect (self.mergeCancel)
        self.ui.lutCB.currentIndexChanged.connect (self.lutChanged)

        self.ui.mergeProgressBar.setValue (0)

        # display adjustments
        self.ui.imageMinLE.returnPressed.connect (self.dispMinPressed)
        self.ui.imageMaxLE.returnPressed.connect (self.dispMaxPressed)

        self.ui.saveProjSetButton.clicked.connect (self.saveProj)
        self.ui.loadProjSetButton.clicked.connect (self.readProj)

        self.ui.pushButton_Detector_Open_calibration.clicked.connect(self.openDetectorCalibration)
        self.ui.pushButton_Detector_Save_calibration.clicked.connect(self.saveDetectorCalibration)

        self.ui.Peaks_Button_Search.clicked.connect(self.SearchForPeaks)
        self.ui.ps_peak_search_button.clicked.connect (self.SearchForPeaks)

        self.ui.updateImageDispButton.clicked.connect(self.updateImage)
        self.ui.maxDNSlider.valueChanged.connect(self.maxSliderUpdate)
        self.ui.minDNSlider.valueChanged.connect(self.minSliderUpdate)
        self.ui.zoomFacBox.valueChanged.connect(self.zoomFacUpdate)
        self.ui.imageWidget.centPt.connect(self.newCent)
        self.ui.imageWidget.addPeakSignal.connect(self.newPeak)
        self.ui.imageWidget.selectRectSignal.connect(self.selectRect)
        self.ui.imageWidget.maskRectSignal.connect(self.maskRect)
        self.ui.imageWidget.setButtonModeSignal.connect(self.setButtons)
        self.ui.imageWidget.imcoordsSelectSignal.connect (self.imageMouseClicked)
        self.ui.peakZoomWidget.slideBarSignal.connect (self.newPeakProfLocation)
        self.ui.peakZoomCalcWidget.barFlag = 0
        self.ui.peakZoomResidsWidget.barFlag = 0
        self.ui.zoomWidget.addPeakSignal.connect(self.newPeak)
        self.ui.zoomWidget.setButtonModeSignal.connect(self.setButtons)
        self.ui.zoomWidget.imcoordsSelectSignal.connect (self.imageMouseClicked)
        self.ui.intImageDisplay.setCakeImage ()
        self.ui.zoomButton.clicked.connect(self.zoomMode)
        self.ui.addPeakButton.clicked.connect(self.addPeakMode)
        self.ui.selectButton.clicked.connect(self.selectMode)
        self.ui.unselectButton.clicked.connect(self.unselectMode)
        self.ui.maskButton.clicked.connect(self.maskMode)
        self.ui.unmaskButton.clicked.connect(self.unmaskMode)
        self.ui.list1Button.toggled.connect(self.listButtonChanged)
        self.ui.peaks_peakListWidgetTable.itemClicked.connect(self.peakListClicked)

        self.ui.peakListWidget.itemSelectionChanged.connect(self.PeakListBrowse)


        # peak tab buttons
        self.ui.selectAllButton.clicked.connect(self.selAllPeaks)
        self.ui.clearAllButton.clicked.connect(self.clearAllPeaks)
        self.ui.mvSelPeaksButton.clicked.connect(self.moveSelPeaks)
        self.ui.delSelPeaksButton.clicked.connect(self.delSelPeaks)
        self.ui.seriesSrchButton.clicked.connect(self.SearchForPeaksSeries)
        self.ui.peakSaveBoxsizeLE.returnPressed.connect (self.peakBoxSizeSet)
        self.ui.peakProfOrientCB.currentIndexChanged.connect (self.peakProfOrientationSet)
        self.ui.adjustPeakDisplaysButton.clicked.connect(self.adjustPeakDisplays)
        self.ui.peaks_peakListWidgetTable.horizontalHeader().setVisible(True)


        # self.ui.clearAllButton.clicked.connect(self.RemoveAllPeaks)

        self.ui.Peaks_Button_Open_PT.clicked.connect(self.OpenPeakTable)
        self.ui.Peaks_Button_Save_PT.clicked.connect(self.SavePeakTable)


        self.ui.zoomWidget.zmRectSignal.connect(self.newZmBox)
        self.ui.maxDNSlider.setRange(0, 65535)
        self.ui.minDNSlider.setRange(0, 65535)
        self.ui.maxDNSlider.setSingleStep(100)
        self.ui.minDNSlider.setSingleStep(100)
        self.ui.maxDNSlider.setValue(1000)
        self.ui.minDNSlider.sliderReleased.connect (self.minmaxDNSliderReleased)
        self.ui.maxDNSlider.sliderReleased.connect (self.minmaxDNSliderReleased)


        self.ui.rangeSlider.setSingleStep(1)
        self.workDirectory = QtCore.QString('')
        self.imageDirectory = QtCore.QString('')
        self.imageFile = QtCore.QString('')
        self.detectFile = QtCore.QString('')
        self.myim = myImage()
        self.ui.p2_currentImgCB.toggled.connect (self.myim.setSeriesFlag)
        self.zmCentLoc = [500, 500]
        self.activeList = 0
        self.peaks = myPeakTable.myPeakTable()  # This is the active PeakTable
        self.peaks0 = myPeakTable.myPeakTable()  # This is the PeakTable0
        self.peaks1 = myPeakTable.myPeakTable()  # This is the PeakTable1
        self.detector = myDetector.myDetector()
        self.detector.setTopLevel (self)
        #myDetector.myDetector.setTopLevel (self)
        self.ui.peaks_peakListWidgetTable.setDetector (self.detector)
        self.peaks.setActiveList(self.peaks0, self.peaks1, self.activeList)

        self.imageWidget.setPeaks(self.peaks)
        self.zoomWidget.setPeaks(self.peaks)

        self.ui.zoomButton.setStyleSheet("QPushButton {background-color: green}")
        self.ui.addPeakButton.setStyleSheet("QPushButton {background-color: yellow}")
        self.ui.selectButton.setStyleSheet("QPushButton {background-color: yellow}")
        self.ui.unselectButton.setStyleSheet("QPushButton {background-color: yellow}")
        self.ui.maskButton.setStyleSheet("QPushButton {background-color: yellow}")
        self.ui.unmaskButton.setStyleSheet("QPushButton {background-color: yellow}")
        self.ui.refsampLabel.setStyleSheet ("QLabel{background-color:white}")

        # mask tab buttons
        self.ui.clearMaskButton.clicked.connect(self.clearMask)
        self.ui.saveMaskFileButton.clicked.connect(self.saveMask)
        self.ui.readMaskFileButton.clicked.connect(self.readMask)

        self.setValToControl (self.ui.ps_gradAddLE, 2)
        self.setValToControl (self.ui.ps_maxCountLE, 40000)
        self.setValToControl (self.ui.ps_maxCountLE, 40000)
        self.setValToControl (self.ui.ps_minCountLE, 50)
        self.setValToControl (self.ui.ps_smoothWinLE, 2)
        self.setValToControl (self.ui.ps_locBcgrLE, 50)

        #detector tab buttons
        self.ui.readTextDetFileButton.clicked.connect(self.readTextDetect)
        self.ui.writeTextDetFileButton.clicked.connect(self.writeTextDetect)
        self.ui.testCalcButton.clicked.connect (self.testCalc)
        self.ui.det_calibrantCB.setCurrentIndex (1)
        self.ui.det_calibrantCB.currentIndexChanged.connect (self.calibrantChanged)
        self.ui.pushButton_Detector_Refine_calibration.clicked.connect (self.refineCalibration)

        #integrate tab buttons
        self.ui.integrateCurrentButton.clicked.connect(self.intCurrent)
        self.ui.cakeButton.clicked.connect(self.cakeCurrent)
        self.ui.calc2ThetaButton.clicked.connect (self.calc2theta)
        self.detector.tDoneAll.connect (self.done2theta)
        self.ui.integrateCurrentButton.setEnabled (False)
        self.ui.cakeButton.setEnabled (False)

        self.updatePeakNumberLE()
        self.getHome()
        self.ui.tabWidget.setCurrentIndex(0)
        ##.ui.zoomTabWidgets.setCurrentIndex(0)

        #plot tab buttons and signal/slots
        self.ui.plot_inputXYButton.clicked.connect(self.plotXYFromFile)
        self.ui.plot_saveFileButton.clicked.connect(self.savePlotToFile)
        self.ui.plot_updateButton.clicked.connect(self.updatePlot)
        self.ui.plot_overlayXY.clicked.connect (self.overlayPlotFromFile)

        #predict tab
        self.ui.diffImageSimulateButton.clicked.connect (self.startSimulate)

        #Powder tab
        self.ui.JCPDSReadButton.clicked.connect (self.readJCPDS)
        self.ui.XPOWReadButton.clicked.connect (self.readXPOW)

        #Image Type combo box
        self.ui.imtypeCB.setItemData (1, 0, QtCore.Qt.UserRole -1)
        self.ui.imtypeCB.setItemData (2, 0, QtCore.Qt.UserRole -1)
        self.ui.imtypeCB.currentIndexChanged.connect (self.imtypeChanged)

        #peakSave to File
        self.ui.peakSaveButton.clicked.connect (self.peakSaveToFile)
        self.ui.peakFileBrowseButton.clicked.connect (self.peakFileBrowse)

        self.ui.peakProfWidget.setpType(0)
        self.fitarr = None
        str = '%f'%self.detector.dacopen
        self.ui.scan_dacopenLE.setText(str)


        #detector calibration ready...
        self.detector.calPeaks.connect (self.getCalPeaks)


    ## getHome :
    #   get the user's home directory
    #   This is used to then look for the atrex_params.txt file.
    #   If this file is found, the file is read to find the last image loaded, and the last calibration file.
    def getHome(self):

        homedir = os.path.expanduser("~")
        self.paramFile = QtCore.QString("%1/atrex_params.txt").arg(homedir)
        # then check to see if the atrex_params.txt file exists
        # if so, the file is then read to find the last image loaded, and the last calibration file
        status = os.path.isfile(self.paramFile)
        str = QtCore.QString("")
        if (status):
            qf = QtCore.QFile(self.paramFile)
            qf.open(QtCore.QIODevice.ReadOnly)
            qts = QtCore.QTextStream(qf)
            str = qts.readLine()
            if (str.length() > 2):
                self.ui.imDirLE.setText(str)
            str = qts.readLine()
            if (str.length() > 2):
                self.ui.imfileLE.setText(str)
                self.imageFile = str
                print 'displaying ', str
                self.openImageFile(str)
            str = qts.readLine()
            if (str.length() > 2):
                self.ui.outDirLE.setText(str)
            str = qts.readLine()
            if (str.length() > 2):
                self.detectFile = str
                self.detector.read_from_text_file(str.toLatin1().data())
                self.Display_Detector_calibration(self.detector)
            else :
                print 'no last cal file found'

    ## closeEvent
    #  shut down the program cleanly
    def closeEvent(self, event):
        print 'Shutting down....'
        qf = QtCore.QFile(self.paramFile)
        qf.open(QtCore.QIODevice.WriteOnly)
        qts = QtCore.QTextStream(qf)
        if (self.imageDirectory.size() > 1):
            qts << self.imageDirectory << "\r\n"
        else:
            qts << "\r\n"
        if (self.imageFile.size() > 1):
            qts << self.imageFile << "\r\n"
        else:
            qts << "\r\n"
        if (self.workDirectory.size() > 1):
            qts << self.workDirectory << "\r\n"
        else:
            qts << "\r\n"
        if (self.detectFile.size()>1) :
            qts << self.detectFile << "\r\n"
        else:
            qts << "\r\n"
        qf.close()



    ## openImage
    # method to open an image, will query the user via an QFileDialog
    #
    def openImage(self):
        self.mergeDisplayFlag = False
        self.imtypeCB.setCurrentIndex(0)
        wdir = self.ui.imDirLE.text()
        self.imageFile = QtGui.QFileDialog.getOpenFileName(self, 'Open Image', wdir)
        self.myLogWidget.addEvent ("Opening image file %s".self.imageFile.toLatin1().data())
        extension = os.path.splitext(self.imageFile.toLatin1().data())[1]

        #return

        self.base = self.myproj.getImageBase (self.imageFile)

        calfile = self.base+'.cal'
        fi = QtCore.QFileInfo (calfile)
        if (fi.exists()):
            self.detector.read_from_text_file(calfile)
            self.Display_Detector_calibration(self.detector)
        else :
            str = "No cal file found\r\nYou may want to save current cal to series\r\nSee cal->save"
            msgBox = QtGui.QMessageBox ()
            msgBox.setText (str)
            msgBox.exec_()

        # get the path and put it in imDirLE
        # z = QtCore.QDir.separator()
        fi = QtCore.QFileInfo (self.imageFile)
        basename = fi.baseName()
        wdir = self.imageFile.left(self.imageFile.lastIndexOf(basename))
        self.ui.imDirLE.setText(wdir)
        # image file prefix will be used to build new images to display

        #prefind = self.imageFile.lastIndexOf(".tif")
        #self.imageFilePref = self.imageFile.left(prefind - 3)
        self.imageFilePref = self.base
        print 'pref is ', self.imageFilePref
        self.imfileLE.setText(self.imageFile)

        mnmx = getImageRange(wdir, self.imageFile)
        self.ui.minRangeLabel.setText(QtCore.QString.number(mnmx[0]))
        self.ui.maxRangeLabel.setText(QtCore.QString.number(mnmx[1]))
        self.ui.selectedImageLE.setText(QtCore.QString.number(mnmx[2]))
        self.ui.mergeStartLabel.setText (QtCore.QString.number(mnmx[0]))
        self.ui.mergeEndLabel.setText (QtCore.QString.number(mnmx[1]))
        #self.ui.mergeProgressBar.setRange (mnmx[0], 100)
        self.displayImage (self.imageFile)

        self.ui.rangeSlider.setRange(mnmx[0], mnmx[1])
        self.ui.rangeSlider.setValue(mnmx[2])
        self.minRange = mnmx[0]
        self.maxRange = mnmx[1]
        self.firstDisplay = True



    ## openImageFile
    # method to open an image
    # @param filename
    # name of file to open
    # from this file the image base will be established.
    def openImageFile(self, filename):
        self.imageFile = filename
        fi = QtCore.QFileInfo (self.imageFile)
        self.myLogWidget.addEvent ("Opening image file %s"%self.imageFile.toLatin1().data())
        self.base = self.myproj.getImageBase (self.imageFile)
        basename = fi.baseName()
        wdir = self.imageFile.left(self.imageFile.lastIndexOf(basename))
        self.ui.imDirLE.setText(wdir)
        # z = QtCore.QDir.separator()
        # wdir = self.imageFile.left(self.imageFile.lastIndexOf(z))
        # self.ui.imDirLE.setText(wdir)
        # image file prefix will be used to build new images to display

        #prefind = self.imageFile.lastIndexOf(".tif")
        #self.imageFilePref = self.imageFile.left(prefind - 3)
        #print 'pref is ', self.imageFilePref
        print 'filename is ', self.imageFile
        self.imfileLE.setText(self.imageFile)
        self.displayImage(self.imageFile)
        # self.myim.readTiff (self.imageFile)
        #self.ui.imageWidget.writeQImage (self.myim.imArray)
        #mnmx = getImageRange(wdir, self.imageFile)
        mnmx = [self.myproj.minImageNum, self.myproj.maxImageNum, self.myproj.filenum]
        self.ui.minRangeLabel.setText(QtCore.QString.number(mnmx[0]))
        self.ui.maxRangeLabel.setText(QtCore.QString.number(mnmx[1]))
        self.ui.selectedImageLE.setText(QtCore.QString.number(mnmx[2]))
        self.ui.rangeSlider.setRange(mnmx[0], mnmx[1])
        self.ui.rangeSlider.setValue(mnmx[2])
        self.minRange = mnmx[0]
        self.maxRange = mnmx[1]
        str = '%f'%self.myproj.omega0
        self.ui.omega0Lab.setText(str)
        self.ui.pred_startLE.setText (str)
        self.ui.scan_startAngLE.setText (str)
        str='%f'%self.myproj.omegaR
        self.ui.pred_rangeLE.setText (str)
        self.ui.scan_stepAngLE.setText (str)
        str = '%f'%self.myproj.detector
        self.ui.detectorLab.setText (str)
        str = '%f'%self.myproj.chi
        self.ui.chiLab.setText(str)
        str = '%f'%self.myproj.expos
        self.ui.expLab.setText(str)
        str = "%d"%self.myproj.minImageNum
        self.ui.scan_startImageLE.setText(str)
        str = "%d"%self.myproj.numImages
        self.ui.scan_numImagesLE.setText(str)

        calfile = self.base+'.cal'
        fi = QtCore.QFileInfo (calfile)
        if (fi.exists()):
            self.detector.read_from_text_file(calfile)
            self.Display_Detector_calibration(self.detector)
            self.detectFile = calfile
        else :
            str = "No cal file found\r\nYou may want to save current cal to series\r\nSee cal->save"
            msgBox = QtGui.QMessageBox ()
            msgBox.setText (str)
            msgBox.exec_()





        #self.ui.rangeSlider.set

    def peakBoxSizeSet (self) :
        val = self.ui.peakSaveBoxsizeLE.text().toInt()[0]
        self.ui.imageWidget.setPeakBoxSize (val)
        self.ui.imageWidget.repaint()

    def zoomFacUpdate(self, value):
        self.ui.zoomWidget.setZmFac(value)
        if (self.displayedImage):
            self.ui.zoomWidget.writeQImage_lut(self.myim.imArray, self.zmCentLoc)

    def newCent(self, newloc):
        print 'newCent'
        self.zmCentLoc[0] = newloc.x()
        self.zmCentLoc[1] = newloc.y()
        self.ui.zoomWidget.writeQImage_lut(self.myim.imArray, self.zmCentLoc)

    """ newZmBox method called when a the zoom window is updated.
        This sends the zoom rect to the imageWidget to update the zoom box outline.
        """

    def newZmBox(self, zmrect):
        self.ui.imageWidget.setZmRect(zmrect)

    """ updateImage method called when Update button is clicked.
        This will read the selectedImageLE text, convert to an int, then
        calculate the new image name. Final step is then to display that image.
    """


    def dispMinPressed (self) :
        lval = self.imageMinLE.text().toFloat()[0]
        hval = self.imageMaxLE.text().toFloat()[0]
        if (lval > hval) :
            hval = lval +1.
            hvalstr = '%f'%hval
            self.imageMaxLE.setText (hvalstr)
        self.ui.imageWidget.setMinMax (lval, hval)
        self.ui.minDNSlider.setValue (lval)
        self.ui.maxDNSlider.setValue (hval)
        self.updateImage()

    def dispMaxPressed (self) :
        lval = self.imageMinLE.text().toFloat()[0]
        hval = self.imageMaxLE.text().toFloat()[0]
        if (hval < lval) :
            lval = hval - 1.
            lvalstr = '%f'%lval
            self.imageMinLE.setText (lvalstr)
        self.ui.imageWidget.setMinMax (lval, hval)
        self.ui.minDNSlider.setValue (lval)
        self.ui.maxDNSlider.setValue (hval)
        self.updateImage()



    def updateImage(self):
        if self.mergeDisplayFlag :
            self.firstDisplay = False
            self.displayImage (self.mergeFileName)
            return

        # get the image num and convert to float
        #z = QtCore.QChar('0')
        tmpstr = self.ui.selectedImageLE.text()
        imnum = tmpstr.toInt()
        print 'New image number ', imnum[0]
        newimage = self.myproj.getFileNameFromNum (imnum[0])

        #newimage = QtCore.QString("%1%2.tif").arg(self.imageFilePref).arg(imnum[0], 3, 10, z)

        status = self.displayImage(newimage)
        if (status):
            self.ui.imfileLE.setText(newimage)
            self.imageFile = newimage
        self.imtypeFlag = 0


    def imtypeChanged (self, index) :
        self.firstDisplay = True
        if index==0 :
            self.mergeDisplayFlag = False
            self.updateImage()
            self.imtypeFlag = 0
            return
        if index==1 :
            self.mergeDisplayFlag = False
            self.displayCakeImage()
            self.imtypeFlag = 1
        if index==2 :
            self.mergeDisplayFlag = True
            self.displayImage (self.mergeFileName)
            self.imtypeFlag==2


    def newSliderValue(self, newval):
        # val = self.ui.rangeSlider.value()
        self.ui.selectedImageLE.setText(QtCore.QString.number(newval))

    def decrementImageValue(self):
        val = self.ui.rangeSlider.value()
        val = val - 1
        if (val >= self.minRange and val <= self.maxRange):
            self.newSliderValue(val)
            self.ui.rangeSlider.setValue(val)
            self.newImageValue()

    def incrementImageValue(self):
        val = self.ui.rangeSlider.value()
        val = val + 1
        if (val >= self.minRange and val <= self.maxRange):
            self.newSliderValue(val)
            self.ui.rangeSlider.setValue(val)
            self.newImageValue()


    """ newImageValue is called by the range slider callback and updates the selectedImageLE
        image number
    """

    def newImageValue(self):
        QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.BusyCursor))
        self.mergeDisplayFlag = False
        self.ui.imtypeCB.setCurrentIndex (0)
        newval = self.ui.rangeSlider.value()
        imname = self.myproj.getFileNameFromNum (newval)
        self.openImageFile (imname)
        QtGui.QApplication.restoreOverrideCursor()
        self.ui.imfileLE.setText(imname)
        self.imageFile = imname
        return




    """ maxSliderUpdate is called by the DN max slider and updates the text line
        edit box. The value in the edit box is used when 
    """

    def maxSliderUpdate(self, newval):
        self.ui.imageMaxLE.setText(QtCore.QString.number(newval))
        minval = self.ui.minDNSlider.value()
        if (minval >= newval) :
            self.ui.minDNSlider.setValue(newval-1)



    def minmaxDNSliderReleased (self) :
        minval = self.ui.minDNSlider.value()
        maxval = self.ui.maxDNSlider.value()
        self.ui.imageWidget.setMinMax (minval, maxval)
        self.updateImage ()


    """ minSliderUpdate is called by the DN max slider and updates the text line
        edit box. The value in the edit box is used when 
    """

    def minSliderUpdate(self, newval):
        self.ui.imageMinLE.setText(QtCore.QString.number(newval))
        maxval = self.ui.maxDNSlider.value()
        if (newval >= maxval) :
            self.ui.maxDNSlider.setValue(newval+1)

    def lutChanged (self, index) :
        self.imageWidget.setLUT (index)
        self.zoomWidget.setLUT (self.imageWidget.rgb_lut)


    def defImageDir(self):
        self.imageDirectory = QtGui.QFileDialog.getExistingDirectory(self, 'Define Image Directory',
                                                                     self.imageDirectory,
                                                                     QtGui.QFileDialog.ShowDirsOnly)
        # print self.imageDirectory
        self.ui.imDirLE.setText(self.imageDirectory)

    def defWorkDir(self):
        self.workDirectory = QtGui.QFileDialog.getExistingDirectory(self, 'Define Work Directory',
                                                                    self.workDirectory,
                                                                    QtGui.QFileDialog.ShowDirsOnly)
        # print self.imageDirectory
        self.ui.outDirLE.setText(self.workDirectory)
        self.mysim.setWorkDir (self.workDirectory)

    def imageMouseClicked (self, vals) :
        # get the 2-theta
        pixvals=[vals[0], vals[1]]
        self.detector.genTiltMtx ()

        if self.imtypeFlag == 0 :
            tthval = self.detector.calculate_tth_from_pixels(pixvals, self.detector.gonio)
            outstr = QtCore.QString ("X: %1   Y: %2   Val:  %3      2-Theta : %4").arg (vals[0]).arg(vals[1]).arg( vals[2]).arg(tthval)
            self.ui.statusBox.setText (outstr)
        if self.imtypeFlag ==1 :
            print 'hello'
            azim = -180. + 360. * (vals[1]/ 768.)
            tth = vals[0]/768. * self.myim.cakeParams[1]
            intens = self.myim.cakeArr [vals[1], vals[0]]
            outstr = QtCore.QString ("2-Theta: %1  Azim: %2  Val: %3").arg (tth).arg(azim).arg(intens)
            self.ui.statusBox.setText (outstr)

    def displayCakeImage (self) :
        self.imtypeFlag = 1
        self.ui.intImageDisplay.calcHisto (self.myim.cakeArr)
        self.ui.intImageDisplay.writeQImage_lut (self.myim.cakeArr)
        self.ui.imageWidget.calcHisto (self.myim.cakeArr)
        self.ui.imageWidget.writeQImage_lut (self.myim.cakeArr)




    def displayImage(self, filename):

        mn = self.ui.imageMinLE.text().toInt()
        mx = self.ui.imageMaxLE.text().toInt()


        self.imageWidget.setMinMax(mn[0], mx[0])
        self.zoomWidget.setMinMax(mn[0], mx[0])

        qf = QtCore.QFile(filename)
        if (qf.exists() == False):
            qf.close()
            return False
        else:
            qf.close()

        if "h5" in filename :
            self.myim.readHDF5 (filename)
        else :
            self.myim.readTiff(filename)
        ### read in the accompanying settings file for the image
        ### if it exists
        ###
        status = self.myim.readText(filename)
        self.imsize = self.myim.imArraySize
        self.detector.setnopixXY (self.imsize)

        if self.firstDisplay :
            self.firstDisplay = False
            self.imageWidget.calcHisto (self.myim.imArray)
            mn = self.imageWidget.dispMin
            mx = self.imageWidget.dispMax
            self.zoomWidget.setMinMax (mn, mx)
            self.ui.minDNSlider.setValue (mn)
            self.ui.maxDNSlider.setValue (mx)
            #self.myproj = Project()
            #self.myproj.getImageBase (filename)
            #print 'Image base is %s'%self.myproj.base


        if not self.displayedImage:
            self.mymask.createMask(self.myim.imArraySize[0], self.myim.imArraySize[1])
            self.displayedImage = True
        if status:
            str = QtCore.QString("0: %1  R : %2").arg(self.myim.omega0).arg(self.myim.omegaR)
            self.ui.omega0Lab.setText(str)
            # self.ui.omegaRLab.setText (self.myim.omegaR)
            self.ui.chiLab.setText(self.myim.chi)
            self.ui.expLab.setText(self.myim.exposureT)
            self.ui.detectorLab.setText(self.myim.detector)
        # self.ui.imageWidget.writeQImage (self.myim.imArray)

        self.ui.imageWidget.writeQImage_lut(self.myim.imArray)
        #
        self.ui.zoomWidget.writeQImage_lut(self.myim.imArray, self.zmCentLoc)
        self.ui.displayFileLabel.setText(filename)
        return (True)

    """ called by either imageWidget or zoomWidget when a user adds a new peak manually
    """

    def newPeak(self, pt):
        peak = myPeakTable.myPeak()
        peak.setDetxy([pt.x(), pt.y()])
        self.peaks.addPeak(peak)
        lstr = QtCore.QString(" %1\t%2").arg(pt.x()).arg(pt.y())
        self.ui.peakListWidget.addItem(lstr)
        newitem = QtGui.QTableWidgetItem (QtCore.QString("%1").arg(pt.x))

        self.updatePeakNumberLE()
        self.imageWidget.repaint()
        self.zoomWidget.repaint()


    """ update peak list usually called when one of the peakList radio boxes is called
    """

    def updatePeaks (self) :
        self.updatePeakList()
        self.imageWidget.repaint()
        self.zoomWidget.repaint()


    ##
    # updatePeakList
    # after a peak is added or modified, the entire peak list is updated and then readied for display in
    # the appropriate peaklist widget
    def updatePeakList(self):
        self.ui.peakListWidget.clear()
        # curList = self.peaks.peakLists[self.peaks.activeList]
        #for i in range (self.peaks.getpeakno()) :
        #    x=self.peaks.getPeaklistDetX()
        #   y=self.peaks.getPeaklistDetY()
        #  lstr = QtCore.QString(" %1\t%2").arg(x[i]).arg(y[i])
        #   self.ui.peakListWidget.addItem (lstr)
        self.peaks.updatePeaks(self.detector)
        count = 0
        # note that the peakListWidget is minimized, not really using.....
        #for p in self.peaks.peaks:
        #    xy = p.DetXY
        #    lstr = QtCore.QString ("%1\t%2\t%3\t%4\t%5 ").arg(count).arg(p.HKL[0]).arg(p.HKL[1]).arg(p.HKL[2])
        #    #lstr = QtCore.QString(" %1\t%2").arg(xy[0]).arg(xy[1])
        #    self.ui.peakListWidget.addItem(lstr)
        self.ui.peaks_peakListWidgetTable.setPeaks (self.peaks.peaks)
        self.ui.peaks_peakListWidgetTable.setImageFileName (self.imageFile)
    ##
    # peakListCLicked
    # @brief Define a peak for analysis by clicking the combobox listing all peaks already identified.
    def peakListClicked(self, event):
        itemNumber = self.ui.peaks_peakListWidgetTable.currentRow()
        xy = self.peaks.peaks[itemNumber].DetXY
        if (self.oldSelected >= 0) :
            self.peaks.peaks[self.oldSelected].clickSelected = False
        self.peaks.peaks[itemNumber].clickSelected = True


        self.oldSelected = itemNumber

        self.imageWidget.repaint()
        bsize = self.ui.peakSaveBoxsizeLE.text().toInt()[0]
        bsize2 = bsize / 2
        startx = xy[0] - bsize2
        starty = xy[1] - bsize2
        self.peakStartx = startx
        self.peakStarty = starty

        # self.ui.zoomWidget.writeQImage_lut (self.myim.imArray, xy)


        #for demo only
        subdat = self.myim.imArray[xy[1] - bsize2:xy[1] + bsize2+1, xy[0] - bsize2:xy[0] + bsize2+1]
        #self.ui.peakZoomWidget.writeQImage_lut(self.myim.imArray, xy)
        self.ui.peakZoomWidget.arrayToQImage (subdat, startx, starty)
        #filtered = ndimage.gaussian_filter(subdat, 1)

        #resids = subdat - filtered
        #self.ui.peakZoomResidsWidget.arrayToQImage(resids)
        self.selectPeakXY  = xy
        pf = peakFit (subdat)
        pf.fitArr()
        self.fitarr = pf.returnFit ()
        resids = subdat - self.fitarr

        # calculate the correlation coefficient
        #corrcoef = np.corrcoef (self.fitarr, subdat)
        corrcoef = np.corrcoef (self.fitarr.ravel(), subdat.ravel())
        #resids = resids * resids
        rms_std = corrcoef[0][1]
        #rms_std= np.std(resids)
        str = '%5.3f'%rms_std
        self.ui.peakRMSLE.setText(str)
        self.ui.peakZoomCalcWidget.calcHisto (self.fitarr)
        self.ui.peakZoomCalcWidget.arrayToQImage(self.fitarr, startx, starty)
        self.ui.peakZoomResidsWidget.calcHisto (resids)
        self.ui.peakZoomResidsWidget.arrayToQImage(resids, startx, starty)

        self.loadFitParams (pf.fitpars)
        self.plotPeakProf (startx, starty, bsize, self.vertProfFlag)

    def adjustPeakDisplays (self):
        peakAdjDlg = myPeakAdjustDlg ()
        peakAdjDlg.setPeakDisplay (0, self.ui.peakZoomWidget)
        peakAdjDlg.setPeakDisplay (1, self.ui.peakZoomCalcWidget)
        peakAdjDlg.setPeakDisplay (2, self.ui.peakZoomResidsWidget)
        peakAdjDlg.updateLEFields ()
        peakAdjDlg.show()

    def listButtonChanged(self, event):
        status = self.list1Button.isChecked()
        if (status):
            self.peaks.setActiveList(self.peaks0, self.peaks1, 0)
        else:
            self.peaks.setActiveList(self.peaks0, self.peaks1, 1)
        self.updatePeakList();
        self.ui.imageWidget.repaint()
        self.ui.zoomWidget.repaint()


    """ zoomMode turns the cursor in the image and zoom widgets to zoom select
    """

    def loadFitParams (self, fitParams):
        s='%6.1f'%(fitParams[0])
        self.ui.pf_backLE.setText (s)
        s='%7.1f'%(fitParams[1])
        self.ui.pf_peakLE.setText (s)
        s='%7.1f'%(fitParams[2])
        self.ui.pf_peakLocXLE.setText (s)
        s='%7.1f'%(fitParams[3])
        self.ui.pf_peakLocYLE.setText (s)
        s='%7.1f'%(fitParams[4])
        self.ui.pf_XWidthLE.setText (s)
        s='%7.1f'%(fitParams[5])
        self.ui.pf_YWidthLE.setText (s)
        s='%7.1f'%(fitParams[6])
        self.ui.pf_rotationLE.setText (s)


    def zoomMode(self):
        self.ui.imageWidget.zoomOn()
        self.ui.zoomWidget.zoomOn()
        self.setButtons(0)

    def addPeakMode(self):
        self.ui.imageWidget.peakAdd()
        self.ui.zoomWidget.peakAdd()
        self.setButtons(1)

    def selectMode(self):
        self.ui.imageWidget.selectOn()
        self.ui.setButtons(2)

    def unselectMode(self):
        self.ui.imageWidget.unselectOn()
        self.ui.setButtons(3)

    def maskMode(self):
        self.ui.imageWidget.maskOn()
        self.ui.setButtons(4)

    def unmaskMode(self):
        self.ui.imageWidget.unmaskOn()
        self.ui.setButtons(5)

    def selectRect(self, rect, sFlag):
        if (sFlag):
            self.peaks.setSelected(rect)
        else:
            self.peaks.setUnselected(rect)
        self.ui.imageWidget.repaint()

    def maskRect(self, rect, sFlag):
        self.mymask.setMask(rect, sFlag)
        self.ui.imageWidget.applyMask(self.mymask.img)
        self.ui.zoomWidget.applyMask(self.mymask.img)
        self.myim.applyMask(self.mymask.img)

    def clearMask(self):
        self.mymask.resetMask()
        self.ui.imageWidget.applyMask(self.mymask.img)
        self.ui.zoomWidget.applyMask(self.mymask.img)
        self.myim.applyMask(self.mymask.img)

    def saveMask(self):
        outstr = QtGui.QFileDialog.getSaveFileName(self, "Save Filename", self.workDirectory, 'Image File (*.tif)')
        self.mymask.saveToFile(outstr)

    def readMask(self):
        outstr = QtGui.QFileDialog.getOpenFileName(self, "Save Filename", self.workDirectory, 'Image File (*.tif)')
        self.mymask.readTiff(outstr)
        self.ui.imageWidget.applyMask(self.mymask.img)
        self.ui.zoomWidget.applyMask(self.mymask.img)

    def selAllPeaks(self):
        self.peaks.selectAll()
        self.ui.imageWidget.repaint()

    def clearAllPeaks(self):
        self.peaks.unselectAll()
        self.ui.imageWidget.repaint()

    def moveSelPeaks(self):
        self.peaks.moveSelected()
        self.updatePeakNumberLE()
        self.updatePeakList()
        self.ui.imageWidget.repaint()


    def RemoveAllPeaks(self):
        print 'remove all peaks'
        self.peaks.remove_all_peaks()
        self.updatePeakNumberLE()
        self.updatePeakList()
        self.ui.imageWidget.repaint()

    def delSelPeaks(self):
        self.peaks.deleteSelected()
        self.updatePeakNumberLE()
        self.updatePeakList()
        self.ui.imageWidget.repaint()


    """ function to change background button color from gray when mode is inactive to
        yellow when active
    """

    def setButtons(self, buttonNumber):
        self.ui.zoomButton.setStyleSheet("QPushButton {background-color: yellow}")
        self.ui.addPeakButton.setStyleSheet("QPushButton {background-color: yellow}")
        self.ui.selectButton.setStyleSheet("QPushButton {background-color: yellow}")
        self.ui.unselectButton.setStyleSheet("QPushButton {background-color: yellow}")
        self.ui.maskButton.setStyleSheet("QPushButton {background-color: yellow}")
        self.ui.unmaskButton.setStyleSheet("QPushButton {background-color: yellow}")
        if (buttonNumber == 0):
            self.ui.zoomButton.setStyleSheet("QPushButton {background-color: green}")
        if (buttonNumber == 1):
            self.ui.addPeakButton.setStyleSheet("QPushButton {background-color: green}")
        if (buttonNumber == 2):
            self.ui.selectButton.setStyleSheet("QPushButton {background-color: green}")
        if (buttonNumber == 3):
            self.ui.unselectButton.setStyleSheet("QPushButton {background-color: green}")
        if (buttonNumber == 4):
            self.ui.maskButton.setStyleSheet("QPushButton {background-color: green}")
        if (buttonNumber == 5):
            self.ui.unmaskButton.setStyleSheet("QPushButton {background-color: green}")


    """ Update of the line edit to display # of list 1 and list 2 peaks
    """




    def updatePeakNumberLE(self):
        pn = self.peaks.getpeakno()
        pn1 = self.peaks1.getpeakno()
        str = QtCore.QString("List 1 : %1\tList 2 : %2").arg(pn).arg(pn1)
        self.ui.numPeaksLE.setText(str)

    def openDetectorCalibration(self):
        self.Display_Detector_calibration(self.detector)

    def saveDetectorCalibration(self):
        self.Update_Detector_calibration()

    def Display_Detector_calibration(self, det):
        self.ui.LE_Detector_Distance.setText(str(det.getdist()))
        XY = det.getbeamXY()
        self.ui.LE_Detector_Beam_X.setText(str(XY[0]))
        self.ui.LE_Detector_Beam_Y.setText(str(XY[1]))
        PS = det.getpsizeXY()
        self.ui.LE_Detector_Pixel_size_X.setText(str(PS[0]))
        self.ui.LE_Detector_Pixel_size_Y.setText(str(PS[1]))
        self.ui.LE_Detector_Wavelength.setText(str(det.getwavelength()))
        self.ui.LE_Detector_Rotation.setText(str(det.gettiltom()))
        self.ui.LE_Detector_Tilt.setText(str(det.gettiltch()))
        self.ui.LE_Detector_Twist.setText(str(det.gettwist()))
        self.ui.LE_Detector_2theta.setText(str(det.getttheta()))

    def Update_Detector_calibration(self):
        self.detector.setdist(float(self.ui.LE_Detector_Distance.text()))
        self.detector.setwavelength(float(self.ui.LE_Detector_Wavelength.text()))
        self.detector.settiltch(float(self.ui.LE_Detector_Tilt.text()))
        self.detector.settiltom(float(self.ui.LE_Detector_Rotation.text()))
        self.detector.settwist(float(self.ui.LE_Detector_Twist.text()))
        self.detector.setttheta(float(self.ui.LE_Detector_2theta.text()))
        bx = float(self.ui.LE_Detector_Beam_X.text())
        by = float(self.ui.LE_Detector_Beam_Y.text())
        px = float(self.ui.LE_Detector_Pixel_size_X.text())
        py = float(self.ui.LE_Detector_Pixel_size_Y.text())
        self.detector.setbeamXY([bx, by])
        self.detector.setpsizeXY([px, py])


    def SearchForPeaks(self) :
        self.PS (0., 3., 1)

    ##
    # The peak search method for the displayed image.
    def PS(self, om, axis, prog):
        self.detector.genTiltMtx ()
        fitFlag = self .ui.ps_fitPeaksCB.isChecked()
        self.myim.fitFlag = fitFlag
        self.myLogWidget.addEvent ("Start of peak search for displayed image")
        print 'Search for peaks'

        # get the values from controls on peak search tab
        gradadd = self.ui.ps_gradAddLE.text().toFloat()[0]
        maxcount = self.ui.ps_maxCountLE.text().toInt()[0]
        smoothwin = self.ui.ps_smoothWinLE.text().toInt()[0]
        mincount = self.ui.ps_minCountLE.text().toInt()[0]
        locwin = self.ui.ps_locBcgrLE.text().toInt()[0]

        # get num of images, and related Omega info
        ni = self.ui.scan_numImagesLE.text().toInt()[0]
        i0 = self.ui.scan_startImageLE.text().toInt()[0]
        om0 = self.ui.scan_startAngLE.text().toFloat()[0]
        omD = self.ui.scan_stepAngLE.text().toFloat()[0]

        # check for box size (8) do we need this here?
        bx = self.ui.p2_boxSizeLE.text().toInt()[0]
        lcbgr = self.myim.calculate_local_background (0, locwin)
        medsub = np.subtract(self.myim.imArray,lcbgr)
        #lcbgr.tofile ("/home/harold/lcbgr")

        #smoothedArr = self.myim.smooth2 (medsub, smoothwin)
        smoothedArr = self.myim.smoothGauss (medsub, smoothwin, 2)
        self.peaks.zero()

        #smoothedArr.tofile ("/home/harold/smoothed")
        ixarr=[]
        iyarr=[]
        maxelems = locmax (smoothedArr, gradadd, ixarr, iyarr)
        if (maxelems.size > 0) :
            a0 = np.logical_and(maxelems>= mincount, maxelems <= maxcount)
            f1a = np.where (a0 == True)

            if (f1a[0].size > 0) :
                gonio=np.zeros((6),dtype=np.float32)
                gonio [axis] = om
                for f in f1a[0]:
                    newpeak = myPeakTable.myPeak ()
                    newpeak.setDetxy((ixarr[f], iyarr[f]))
                    newpeak.Gonio[:] = gonio
                    newpeak.IntSSD[:]=[bx, bx]
                    self.peaks.addPeak (newpeak)





        # thr=self.threshold                       # 100:       raw counts threshold for locating peaks
        #max_peak_size=self.mindist               # 10:        max allowed peak size with pixels above local background + Imin
        #num_of_segments = [self.pbox,self.pbox]  # [50.,50.]: number of segments in X and Y for local labckground estimation
        #perc=self.bbox                           # 1.0:       percent of median for background

        # need to initialize self.peaks
        #self.myim.search_for_peaks(self.peaks, 100, 10, [50., 50.], 1.0)
        # if the fit CB is checked, then do the 2d gaussian
        # need to evaluate the quality of fit here.
        #
        if self.myim.fitFlag :
            self.myLogWidget ("Starting of peak fitting")
            #self.myim.fitPeaks (self.peaks, 16)
            self.myim.fitAllPeaks (self.peaks, 16)

        # update calibration and then update peaks
        self.Update_Detector_calibration()
        kappa = self.ui.LE_Detector_kappa.text().toFloat()[0]
        theta = self.ui.LE_Detector_2theta.text().toFloat()[0]
        omind = self.ui.pred_omega_or_energyCB.currentIndex()
        if omind == 1 :
            omegaFlag = 0
        else :
            omegaFlag = 1
        # get the xyz from pixel vals
        self.peaks.calculate_all_xyz_from_pix (self.detector, kappa,theta, omegaFlag)


        self.updatePeakNumberLE()
        self.imageWidget.repaint()
        self.zoomWidget.repaint()
        self.updatePeakList()
        self.ui.imageWidget.repaint()
        str = 'Number of peaks found : %d'%self.peaks.getpeakno()
        self.myLogWidget.addEvent (str)
        msg = QtGui.QMessageBox()
        msg.setIcon (QtGui.QMessageBox.Information)
        msg.setInformativeText (str)
        str = 'Image : %s'%self.imageFile
        #msg.setText (str)
        msg.setWindowTitle ("ATREX : Peak Search")
        msg.exec_()
        print str


    def SearchForPeaksSeries(self):

        # get the values from controls on peak search tab
        gradadd = self.ui.ps_gradAddLE.text().toFloat()[0]
        maxcount = self.ui.ps_maxCountLE.text().toInt()[0]
        smoothwin = self.ui.ps_smoothWinLE.text().toInt()[0]
        mincount = self.ui.ps_minCountLE.text().toInt()[0]
        locwin = self.ui.ps_locBcgrLE.text().toInt()[0]

        # get num of images, and related Omega info
        ni = self.ui.scan_numImagesLE.text().toInt()[0]
        i0 = self.ui.scan_startImageLE.text().toInt()[0]
        om0 = self.ui.scan_startAngLE.text().toFloat()[0]
        omD = self.ui.scan_stepAngLE.text().toFloat()[0]

        # check for box size (8) do we need this here?
        bx = self.ui.p2_boxSizeLE.text().toInt()[0]


        self.detector.genTiltMtx ()
        self.peaks.remove_all_peaks()
        z = QtCore.QChar('0')
        tempimg = myImage()
        self.myLogWidget.addEvent ("Start of peak search for series")

        for i in range(self.minRange, self.maxRange):
            #newimage = QtCore.QString("%1%2.tif").arg(self.imageFilePref).arg(i, 3, 10, z)
            newimage = self.myproj.getFileNameFromNum (i)
            self.myLogWidget.addEvent ("Reading in %s for series peak search")
            tempimg.readTiff(newimage)
            lcbgr = tempimg.calculate_local_background (0, locwin)
            smoothedArr = tempimg.smooth2 (tempimg.imArray-lcbgr, smoothwin)
            ixarr=[]
            iyarr=[]
            maxelems = locmax (smoothedArr, gradadd, ixarr, iyarr)

            if (maxelems.size > 0) :
                a0 = np.logical_and(maxelems>= mincount, maxelems <= maxcount)
                f1a = np.where (a0 == True)

            if (f1a[0].size > 0) :
                gonio=np.zeros((6),dtype=np.float32)
                gonio [axis] = om
                for f in f1a[0]:
                    newpeak = myPeakTable.myPeak ()
                    newpeak.setDetxy((ixarr[f], iyarr[f]))
                    newpeak.Gonio[:] = gonio
                    newpeak.IntSSD[:]=[bx, bx]
                    self.peaks.addPeak (newpeak)

        self.updatePeakNumberLE()
        self.imageWidget.repaint()
        self.zoomWidget.repaint()
        self.updatePeakList()
        self.ui.imageWidget.repaint()

    def mergeCancel (self) :
        self.cancelMerge = True


    ## merge images in the image series
    #   This is a simple pixel by pixel summing of the images.
    def mergeImageRange(self):
        # get the output tif file name....
        tempimg = myImage()
        outname = QtGui.QFileDialog.getSaveFileName(self, "Merge Filename", self.workDirectory, "Image File (*.tif)")
        self.cancelMerge = False
        z = QtCore.QChar('0')
        self.mergeSumMode = self.ui.sumButton.isChecked()
        self.ui.mergeProgressBar.setValue (0) ;

        self.ui.mergeCancelButton.setEnabled (True)
        nimages = self.maxRange - self.minRange + 1

        if (self.mergeSumMode == True):

            for i in range(self.minRange, self.maxRange + 1):
                QtCore.QCoreApplication.processEvents()
                if self.cancelMerge :
                    msgBox = QtGui.QMessageBox ()
                    msgBox.setText ("Merge cancelled, returning...")
                    msgBox.exec_()
                    self.ui.mergeCancelButton.setEnabled (False)
                    self.ui.mergeProgressBar.setValue (0)
                    return
                percentDone = float(i-self.minRange) / nimages * 100.
                self.ui.mergeProgressBar.setValue (percentDone)
                newimage = QtCore.QString("%1%2.tif").arg(self.imageFilePref).arg(i, 3, 10, z)
                tempimg.readTiff(newimage)
                if i == self.minRange:
                    self.mergeArr = tempimg.imArray.copy().astype(np.float32)
                else:
                    self.mergeArr = tempimg.imArray + self.mergeArr

            maxval = np.max(self.mergeArr)
            if (maxval > 65535):
                scaleval = 65534. / maxval
                str = QtCore.QString("Merge exceeds 65535, scaled by %1").arg(scaleval)
                # qinfo = QtGui.QMessageBox.warning(None, "Information", str)
                self.mergeArr *= scaleval
        else:
            for i in range(self.minRange, self.maxRange + 1):
                percentDone = float(i-self.minRange) / nimages * 100.
                self.ui.mergeProgressBar.setValue (percentDone)
                newimage = QtCore.QString("%1%2.tif").arg(self.imageFilePref).arg(i, 3, 10, z)
                tempimg.readTiff(newimage)
                if i == self.minRange:
                    self.mergeArr = tempimg.imArray.copy().astype(np.float32) / nimages
                else:
                    self.mergeArr = tempimg.imArray / nimages + self.mergeArr


        self.ui.mergeProgressBar.setValue (100)
        # if maxval > 65535 :
        #    mergeArr = mergeArr / maxval * 655354.
        self.mergeArr = self.mergeArr.astype(np.uint16)
        # now write to tif file
        #im = Image.fromarray (mergeArr.astype(np.float32))
        #im.save (outname.toLatin1().data())
        imsave(outname.toLatin1().data(), self.mergeArr)
        #self.openImageFile (outname)
        self.mergeDisplayFlag = True
        self.firstDisplay = True
        self.displayImage (outname)
        self.mergeFileName = outname
        self.ui.imtypeCB.setItemData (2, 33, QtCore.Qt.UserRole -1)
        self.ui.imtypeCB.setCurrentIndex (2)
        self.ui.mergeCancelButton.setEnabled (False)

    def SavePeakTable(self):
        print 'write PT'
        wdir = self.ui.imDirLE.text()
        PTFile = QtGui.QFileDialog.getSaveFileName(self, 'Save Peak Table', wdir)
        self.peaks.write_to_fileA(PTFile)

    def OpenPeakTable(self):
        print 'read PT'
        wdir = self.ui.imDirLE.text()
        PTFile = QtGui.QFileDialog.getOpenFileName(self, 'Open Peak Table', wdir)
        #self.peaks.read_from_file(PTFile)
        self.peaks.read_from_fileA(PTFile)
        self.updatePeakNumberLE()
        self.updatePeakList()
        self.ui.imageWidget.repaint()

    def PeakListBrowse(self):
        print 'peak list browse', self.ui.peakListWidget.currentRow()
        self.zmCentLoc[0] = 200
        self.zmCentLoc[1] = 300


    def readTextDetect(self):
        detfile = QtGui.QFileDialog.getOpenFileName(self, 'Open Detector File', self.workDirectory)
        self.detectFile = detfile
        self.detector.read_from_text_file(detfile.toLatin1().data())
        self.Display_Detector_calibration(self.detector)

    def writeTextDetect(self):
        self.Update_Detector_calibration()
        detfile = QtGui.QFileDialog.getSaveFileName(self, 'Output Detector File', self.workDirectory)
        self.detector.write_to_text_file(detfile.toLatin1().data())


    def updatePlot(self):
        ptype = 0
        if (self.ui.symbCB.isChecked()):
            ptype = 1
        if (self.ui.splineCB.isChecked()):
            ptype |= 2
        self.ui.myplotWidget.setpType(ptype)
        # self.ui.myplotWidget.replot()
        tstr = self.ui.plot_titleLE.text().toLatin1().data()
        xstr = self.ui.plot_xLE.text().toLatin1().data()
        ystr = self.ui.plot_yLE.text().toLatin1().data()
        self.myplotWidget.setLabels(tstr, xstr, ystr)
        self.myplotWidget.plotData()

    def savePlotToFile(self):
        filename = QtGui.QFileDialog.getSaveFileName(self, 'Output Plot Image', self.workDirectory,
                                                     "Image File (*.png)")
        len = filename.length()
        if (len < 1): return
        self.myplotWidget.outputToFile(filename.toLatin1().data())


    def plotXYFromFile(self):

        filename = QtGui.QFileDialog.getOpenFileName(self, 'ASCII XY File', self.workDirectory, "Text File (*.txt)")
        len = filename.length
        if (len < 1): return
        file = open (filename.toLatin1().data(), 'r')
        xvals =[]
        yvals =[]
        i = 0
        for line in file :
            i = i+ 1
            line = line.strip()
            lineList = line.split(" ")
            xvals.append (float(lineList[0]))
            yvals.append (float(lineList[1]))
        self.myplotWidget.setXYData (xvals, yvals)

    def overlayPlotFromFile (self) :
        olayDlg = MyOverlayDlg ()
        olayDlg.setParams (self.olayFile, self.olaySecFlag)
        olayDlg.exec_()
        xvals =[]
        yvals =[]
        i=0

        file = open (olayDlg.infile, "r")
        for line in file :
            i = i+ 1
            line = line.strip()
            lineList = line.split(" ")
            xvals.append (float(lineList[0]))
            yvals.append (float(lineList[1]))
        self.myplotWidget.setOverlayXYData (xvals, yvals, False)

    def readXPOW (self) :
        table = self.ui.refSampleTabWidget
        table.clearContents()
        filename = QtGui.QFileDialog.getOpenFileName(self, "Input .txt File")
        refsamp = JCPDS ()
        refsamp.read_xpow (filename.toLatin1().data())
        propString = refsamp.getParamString()
        nrows = len (propString) / 2
        #nrowsTable=self.ui.refSampleTabWidget.rowCount()
        #if nrows > nrowsTable :
        self.ui.refSampleTabWidget.setRowCount (nrows)
        for i in range(nrows) :

            itemTitle = QtGui.QTableWidgetItem ()
            itemTitle.setBackgroundColor (QtCore.Qt.yellow)
            itemValue = QtGui.QTableWidgetItem ()
            itemTitle.setText (propString[i*2])
            itemValue.setText (str(propString[i*2+1]).strip())
            table.setItem (i, 0, itemTitle)
            table.setItem (i, 1, itemValue)

        # then load up the reflection table
        table = self.ui.sampleReflectTabWidget
        table.clearContents()
        nrows = len (refsamp.reflections)

        table.setRowCount (nrows)
        count = 0
        for r in refsamp.reflections :
            itemD = QtGui.QTableWidgetItem ()
            itemD.setText (str(r.d0))
            table.setItem (count, 0, itemD)
            itemIntens = QtGui.QTableWidgetItem ()
            itemIntens.setText (str(r.inten))
            table.setItem (count, 1, itemIntens)
            itemH = QtGui.QTableWidgetItem ()
            itemH.setText (str(r.h))
            table.setItem (count, 2, itemH)
            itemK = QtGui.QTableWidgetItem ()
            itemK.setText (str(r.k))
            table.setItem (count, 3, itemK)
            itemL = QtGui.QTableWidgetItem ()
            itemL.setText (str(r.l))
            table.setItem (count, 4, itemL)
            count += 1
        self.ui.refsampLabel.setText (filename)

    def readJCPDS (self):
        table = self.ui.refSampleTabWidget
        table.clearContents()
        filename = QtGui.QFileDialog.getOpenFileName(self, "Input .jcpds File")
        refsamp = JCPDS ()
        refsamp.read_file (filename)
        propString = refsamp.getParamString()

        nrows = len (propString) / 2
        #nrowsTable=self.ui.refSampleTabWidget.rowCount()
        #if nrows > nrowsTable :
        self.ui.refSampleTabWidget.setRowCount (nrows)
        for i in range(nrows) :

            itemTitle = QtGui.QTableWidgetItem ()
            itemTitle.setBackgroundColor (QtCore.Qt.yellow)
            itemValue = QtGui.QTableWidgetItem ()
            itemTitle.setText (propString[i*2])
            itemValue.setText (str(propString[i*2+1]).strip())
            table.setItem (i, 0, itemTitle)
            table.setItem (i, 1, itemValue)

        nrows = len (refsamp.reflections)

        # then load up the reflection table
        table = self.ui.sampleReflectTabWidget
        table.clearContents()
        table.setRowCount (nrows)
        count = 0
        for r in refsamp.reflections :
            itemD = QtGui.QTableWidgetItem ()
            itemD.setText (str(r.d0))
            table.setItem (count, 0, itemD)
            itemIntens = QtGui.QTableWidgetItem ()
            itemIntens.setText (str(r.inten))
            table.setItem (count, 1, itemIntens)
            itemH = QtGui.QTableWidgetItem ()
            itemH.setText (str(r.h))
            table.setItem (count, 2, itemH)
            itemK = QtGui.QTableWidgetItem ()
            itemK.setText (str(r.k))
            table.setItem (count, 3, itemK)
            itemL = QtGui.QTableWidgetItem ()
            itemL.setText (str(r.l))
            table.setItem (count, 4, itemL)
            count += 1


        self.ui.refsampLabel.setText (filename)

    """ Callback from integrateCurrentButton click
    """
    def intCurrent (self):
        # need to put a check in here to make sure that the ttheta image exists
        tthetaArr = np.zeros (self.imsize, dtype=np.float32)
        #f = open ('/home/harold/ttheta', 'r')
        #tthetaArr = np.fromfile (f,dtype=np.float32).reshape(self.imsize)
        #f.close()
        self.myim.integrate (self.detector.getbeamXY(), self.detector.tthetaArr)
        self.integratePlotWidget.setXYData_Integrate (self.myim.tthetabin, self.myim.avg2tth)


    def cakeCurrent (self):
        saveFlag = False

        # check to see if the user would like to save the cake Array to file
        if (self.ui.saveCakeCB.isChecked()) :
            saveFlag = True
            outfile = QtGui.QFileDialog.getSaveFileName (None, "Cake OutputFile", self.workDirectory, "Tiff file (*.tif)")
        self.myim.cake (self.detector.getbeamXY(),self.detector.tthetaArr)
        #self.integratePlotWidget.setXYData_Integrate (self.myim.tthetabin, self.myim.avg2tth)

        self.displayCakeImage()
        str = QtCore.QString ("%1").arg(int(self.myim.cakeParams[1]))

        self.ui.maxTTHLab.setText (str)
        #Image Type combo box
        self.ui.imtypeCB.setItemData (1, 33, QtCore.Qt.UserRole -1)
        self.ui.imtypeCB.setCurrentIndex (1)



        if saveFlag :
            imsave (outfile.toLatin1().data(), self.myim.cakeArr)
            txtstr = QtCore.QString("%1.txt").arg(outfile)
            tfile = file (txtstr.toLatin1().data(), 'w')
            str = "Cake Image (y: azimuth x: 2d-theta)\n"
            tfile.writelines(str)
            str = "Source File : %s\n"%(self.myim.imFileName)
            tfile.writelines (str)
            str = "Top Azimuth : -180."
            str1 = "Bot Azimuth : 180."
            str2 = "Az Spacing : %.3f"%(self.myim.cakeParams[5])
            outstr = "%s\n%s\n%s\n"%(str, str1, str2)
            tfile.writelines (outstr)
            str= "Min 2-theta : %.1f"%(self.myim.cakeParams[0])
            str1= "Max 2-theta : %.1f"%(self.myim.cakeParams[1])
            str2 = "2-theta Spacing : %.3f"%(self.myim.cakeParams[2])
            outstr = "%s\n%s\n%s\n"%(str, str1, str2)
            tfile.writelines (outstr)

            tfile.close()



            #self.myim.cakeArr.tofile (outfile.toLatin1().data())


    def testCalc (self) :
        #self.detector.create_ttheta_array (self.myim.imArraySize)
        self.detector.testCalibration(self.myim)

    def refineCalibration (self) :
        self.detector.setRefineTwist(self.ui.refineTwistCB.isChecked())
        self.detector.refineCalibration(self.myim)

    def calc2theta (self) :
        self.Update_Detector_calibration()
        saveFlag = self.ui.save2ThetaCB.isChecked()
        self.detector.calc2theta(saveFlag)

    def done2theta (self) :
        self.ui.integrateCurrentButton.setEnabled(True)
        self.ui.cakeButton.setEnabled(True)


    def peakFileBrowse (self) :
        str = QtGui.QFileDialog.getSaveFileName (None, "Save to Peak Filename", self.workDirectory, "Any file (*.*);;Tiff file (*.tif)" )
        self.ui.peakSaveFilenameLE.setText(str)

    def peakSaveToFile (self) :
        startULeft = [0,0]
        bsize = self.ui.peakSaveBoxsizeLE.text().toInt()
        bsize = bsize[0]
        startULeft[0] = self.selectPeakXY[0]- bsize/2
        startULeft[1] = self.selectPeakXY[1]- bsize/2
        if startULeft[0] < 0 :
            startULeft[0] = 0
        if startULeft[1] < 0 :
            startULeft[1] = 0
        outArr = self.myim.imArray_orig [startULeft[1]:startULeft[1]+bsize,startULeft[0]:startULeft[0]+bsize]
        outArrInt = outArr.astype (dtype=np.uint16)
        #check if flat or tiff
        flatFlag = self.ui.peakSaveFileTypeRB.isChecked()

        #get file name
        outfile = self.ui.peakSaveFilenameLE.text()

        #then save to flat file
        if flatFlag :
            outArrInt.tofile (outfile.toLatin1().data())
            outfile_hdr = "%s.txt"% outfile.toLatin1().data()
            f = open (outfile_hdr, 'wb')
            str = "Peak File - raw data\r\n"
            f.write(str)
            str = "nlines : %d\r\n"%bsize
            f.write(str)
            str = "nsamps : %d\r\n"%bsize
            f.write(str)
            str = "dtype : uint16\r\n"
            f.write(str)
            f.close()
        #or tiff file
        else :
            imsave (outfile, outArrInt)

    ##
    #   Function to plot the vertical or horizontal profile of the peak
    #   Vert flag controlled by combo-box selection
    #   This is only for first time, when vbar or hbar is centered on the image
    def plotPeakProf (self, x, y, npts, vFlag):
        xpts=[]
        ypts=[]
        yptsFit=[]
        #check for vert or horiz flag
        if (vFlag==1) :
            for i in range(npts):
                xpts.append( y + i)
                ypts.append(self.myim.imArray[y+i,x+npts/2])
                yptsFit.append (self.fitarr[y-self.peakStarty+i, x-self.peakStartx+npts/2])
        # horiz profile
        if (vFlag==2) :
            for i in range(npts):
                xpts.append(x + i)
                ypts.append(self.myim.imArray[y+npts/2,x+i])
                yptsFit.append (self.fitarr[y-self.peakStarty+npts/2, x-self.peakStartx+i])
        self.peakProfWidget.plotDataXY2 (xpts, ypts, yptsFit)

    def newPeakProfLocation (self, vFlag, x, y) :
        xpts=[]
        ypts=[]
        yptsFit=[]
        #check for vert or horiz flag
        npts = self.ui.peakSaveBoxsizeLE.text().toInt()[0]
        # vert profile
        if (vFlag==1) :
            for i in range(npts):
                xpts.append( y + i)
                ypts.append(self.myim.imArray[y+i,x])
                yptsFit.append (self.fitarr[y-self.peakStarty+i, x-self.peakStartx])
        # horiz profile
        if (vFlag==2) :
            for i in range(npts):
                xpts.append(x + i)
                ypts.append(self.myim.imArray[y,x+i])
                yptsFit.append (self.fitarr[y-self.peakStarty, x-self.peakStartx+i])

        self.peakProfWidget.plotDataXY2 (xpts, ypts, yptsFit)

    def peakProfOrientationSet (self, index) :
        vFlag = index+1
        npts = self.ui.peakSaveBoxsizeLE.text().toInt()[0]
        self.ui.peakZoomWidget.setBarFlag (vFlag)
        if (vFlag==1) :
            self.newPeakProfLocation (vFlag, self.peakStartx+npts/2, self.peakStarty)
        if (vFlag==2) :
            self.newPeakProfLocation (vFlag, self.peakStartx, self.peakStarty+npts/2)


    def readPredictSettings(self):
        self.mypred.om_range = self.ui.pred_rangeLE.text().toFloat()[0]
        self.mypred.om_start = self.ui.pred_startLE.text().toFloat()[0]
        self.mypred.partOverlap =  self.ui.pred_partOverlapLE.text().toFloat()[0]
        self.mypred.fullOverlap = self.ui.pred_fullOverlapLE.text().toFloat()[0]
        self.mypred.h1 = self.ui.pred_h0LE.text().toInt()[0]
        self.mypred.h2 = self.ui.pred_h1LE.text().toInt()[0]
        self.mypred.k1 = self.ui.pred_k0LE.text().toInt()[0]
        self.mypred.k2 = self.ui.pred_k1LE.text().toInt()[0]
        self.mypred.l1 = self.ui.pred_l0LE.text().toInt()[0]
        self.mypred.l2 = self.ui.pred_l1LE.text().toInt()[0]
        self.mypred.dacopen = self.ui.scan_dacopenLE.text().toFloat()[0]

    def calibrantChanged (self, ind):
        self.detector.setCalibrant (ind)


    def startSimulate (self) :
        self.readPredictSettings()
        self.mysim = simulateDlg.simulateDlg()
        self.mysim.setProject (self.myproj)
        self.mysim.setBSizeControl (self.ui.p2_boxSizeLE)
        self.mysim.setExcludeControl (self.ui.im_excludeCB)
        self.mysim.setPredict (self.mypred)
        self.mysim.setDetector (self.detector)
        self.mysim.setPeakTable (self.peaks)
        self.mysim.show ()
        self.mysim.updatePeaks.connect (self.updatePeaks)
        self.mysim.updateDisplay.connect(self.updateDisplay)

    def updateDisplay (self) :
        self.imageWidget.repaint()
        self.zoomWidget.repaint()
        self.updatePeakList()
        self.ui.imageWidget.repaint()

    # return 0 if 1, 1 if all
    def read_box_change (self):
        state = (self.ui.p2_box_change_1.isChecked())
        if (state) :
            return 0
        return 1

    def getCalPeaks (self) :
        self.imageWidget.setCalibrationMarks (self.detector.ff, 500.)
        self.imageWidget.setProxPoints ([self.detector.eqprox[0],self.detector.eqprox[1]],[self.detector.eqproxfine[0],self.detector.eqproxfine[1]])
        self.imageWidget.setRingPoints (self.detector.numRings, self.detector.rgN, self.detector.rgx, self.detector.rgy)

    def read_inversions (self, outarr) :
        if self.ui.im_invertXCB.isChecked() :
            outarr[0] = 1
        else :
            outarr[0] = 0

        if self.ui.im_invertYCB.isChecked() :
            outarr[1] = 1
        else :
            outarr[1] = 0

        if self.ui.im_transposeCB.isChecked() :
            outarr[2] = 1
        else :
            outarr[2] = 0
        return
    def set_inversions (self, arr):
        setval = False
        if arr[0] == 1 :
            setval = True
        self.ui.im_invertXCB.setChecked (setval)
        setval = False
        if arr[1] == 1 :
            setval = True
        self.ui.im_invertYCB.setChecked (setval)
        setval = False
        if arr[2] == 1 :
            setval = True
        self.ui.im_transposeCB.setChecked (setval)


    def saveProj (self) :
        basestring = self.myproj.base+'projset.txt'
        outfile = QtGui.QFileDialog.getSaveFileName (self, "Project Settings File", basestring)
        qf = QtCore.QFile (outfile)
        qf.open(QtCore.QIODevice.WriteOnly)
        qts = QtCore.QTextStream(qf)
        zeroOff = self.ui.scan_zeroOffLE.text().toFloat()[0]
        dacOpen = self.ui.scan_dacopenLE.text().toFloat()[0]
        #self.detector.dacopen = dacOpen
        corrArr = [0,0,0,0]
        invArr = [0,0,0]
        self.load_corrections (corrArr)
        self.read_inversions (invArr)

        qts << "Zero Offset : \t" << zeroOff << "\r\n"
        qts  << "DAC Open : \t" << dacOpen << "\r\n"
        qts << "DAC Abs : \t" << corrArr[0] << "\r\n"
        qts << "Omega Rotation Dir : \t" << self.getOmegaRotationDir () << "\r\n"
        qts << "X Inversion : \t" << invArr[0] << "\r\n"
        qts << "Y Inversion : \t" << invArr [1] << "\r\n"
        qts << "Transpose : \t" << invArr [2] << "\r\n"
        qf.close()

        return

    def readProj (self) :
        basestring = self.myproj.base+'projset.txt'
        pfile = QtGui.QFileDialog.getOpenFileName (self, "Project Settings File", basestring)
        qf = QtCore.QFile (pfile)
        qf.open(QtCore.QIODevice.ReadOnly)
        xinversion = 0
        yinversion = 0
        transpose = 0
        while (1) :
            qts = QtCore.QTextStream(qf)
            str = qts.readLine ()
            if str.length() < 1 :
                break
            strlist = str.split (":")
            if (str.contains("Zero")) :
                zeroOff = strlist[1].toFloat()
            if (str.contains ("Open")) :
                dacOpen = strlist[1].toFloat()
            if (str.contains ("Abs")) :
                dacabs = strlist[1].toInt()
                if (dacabs ==1) :
                    self.ui.intcor_dacAbsCB.setChecked(True)
            if (str.contains("Omega")) :
                omegaRot = strlist[1].toInt()
                if omegaRot <0 :
                    self.ui.scan_omegaRotDirCB.setChecked()
            if (str.contains("X")) :
                xinversion = strlist[1].toInt()
            if (str.contains("Y")) :
                yinversion = strlist[1].toInt()
            if (str.contains ("Transpose")):
                transpose = strlist[1].toInt()

        self.set_inversions ([xinversion, yinversion, transpose])






    def load_corrections (self, arr):
        for i in range (4):
            arr[i] = 0
        if self.ui.intcor_dacAbsCB.isChecked() :
            arr[0] = 1
        if self.ui.intcor_lorenzCB.isChecked() :
            arr[1] = 1
        if self.ui.intcor_polarCB.isChecked() :
            arr[2] = 1
        if self.ui.intcor_verPolCB.isChecked() :
            arr[3] = 1

        return

    def getOmegaRotationDir (self) :
        if self.ui.scan_omegaRotDirCB.isChecked() :
            dir = -1
        else :
            dir = 1
        return dir

    def getPeakSearchFitParams (self) :
        gradadd = self.ui.ps_gradAddLE.text().toInt()[0]
        maxcount = self.ui.ps_maxCountLE.text().toInt()[0]
        mincount = self.ui.ps_minCountLE.text().toInt()[0]
        smoothwin = self.ui.ps_smoothWinLE.text().toInt()[0]
        locBcgr = self.ui.ps_locBcgrLE.text().toInt()[0]
        fitB = self.ui.ps_fitPeaksCB.isChecked()
        self.myim.setFitParams (fitB, gradadd, maxcount, mincount, smoothwin, locBcgr)
        bs2 = self.ui.ps2_boxSizeLE.text().toInt()[0]
        self.myim.setBS2 (bs2)

    def setValToControl (self, control, val) :
        str = QtCore.QString ("%1").arg(val)
        control.setText(str)




app = QtGui.QApplication(sys.argv)
atrex = Atrex()
atrex.show()

sys.exit(app.exec_())
